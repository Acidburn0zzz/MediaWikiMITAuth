<?php

/**
 * Class which represents the credentials for an account from MIT or related
 * identity provider.
 */
class MITAuthCredentials {
	public $provider;
	public $username;

	public function __construct( $username, $provider = 'MIT' ) {
		$this->provider = $provider;
		$this->username = $username;
	}

	/**
	 * Returns whether the link is to native MIT account.
	 */
	public function isMIT() {
		return $this->provider == 'MIT';
	}

	/**
	 * Returns a displayable internationalized form of name and provider.
	 */
	public function getDisplayName() {
		switch( $this->provider ) {
			case 'MIT':
				return wfMsg( 'mitauth-accttype-native', $this->username );
		}
	}

	/**
	 * Converts the credentials into string.
	 */
	public function serialize() {
		return "{$this->provider}::{$this->username}";
	}

	/**
	 * Converts the valid string into credentials.
	 */
	public static function unserialize( $str ) {
		list( $provider, $username ) = explode( '::', $str, 2 );
		return new self( $username, $provider );
	}
}

/**
 * Generic methods related to authentication.
 */
class MITAuth {
	const MARK_LENGTH = 16;
	const MARK_EXPIRY = 60;
	const MARK_EXPIRY_LONG = 600;
	const GROUP_EXPIRY = 300;

	/**
	 * We use a pluggable backend, which currently only supports
	 * certificates but may get Shibboleth support in the future.
	 */
	private static function getBackend() {
		static $singleton;

		if( !$singleton ) 
			$singleton = new MITAuthCertificates();

		return $singleton;
	}

	// Methods
	public static function getAuthenticationData() { return self::getBackend()->getAuthenticationData(); }
	public static function redirectToAuthenticator( $type, $query = '' ) { return self::getBackend()->redirectToAuthenticator( $type, $query ); }

	/**
	 * Gets the cache which actually works, avoiding dummy clients
	 * which will cause authentication marks fail epically.
	 */
	public static function getRealCache() {
		global $wgMainCacheType, $wgMemc, $parserMemc;

		if( $wgMainCacheType == CACHE_NONE ) {
			return $parserMemc;
		} else {
			return $wgMemc;
		}
	}

	/**
	 * Lookup user credential for the given user. Returns MITAuthCredentials
	 * or null if the account is not linked.
	 */
	public static function getUserCredentials( $user, $useMaster = false ) {
		// TODO: add caching
		if( !$user instanceof User ) {
			$user = User::newFromName( $user );
			if( !$user )
				return null;
		}

		$dbr = wfGetDB( $useMaster ? DB_MASTER : DB_SLAVE );
		$row = $dbr->selectRow( 'mit_account_links', '*', array( 'mal_user_id' => $user->getID() ), __METHOD__ );
		if( $row ) {
			return new MITAuthCredentials( $row->mal_linked_name, $row->mal_linked_provider );
		} else {
			return null;
		}
	}

	/**
	 * Lookup user by linked credentials. Returns User object or null.
	 */
	public static function getUserByCredentials( $credentials, $useMaster = false ) {
		// TODO: add caching

		$dbr = wfGetDB( $useMaster ? DB_MASTER : DB_SLAVE );
		$row = $dbr->selectRow( 'mit_account_links', 'mal_user_id', array( 'mal_linked_provider' => $credentials->provider, 'mal_linked_name' => $credentials->username ), __METHOD__ );
		if( $row ) {
			return User::newFromId( $row->mal_user_id );
		} else {
			return null;
		}
	}

	/**
	 * Establish a link between a MediaWiki user and MIT account.
	 */
	public static function linkUserAccount( $user, $credentials ) {
		$dbw = wfGetDB( DB_MASTER );
		$dbw->insert(
			'mit_account_links',
			array(
				'mal_user_id' => $user->getID(),
				'mal_linked_provider' => $credentials->provider,
				'mal_linked_name' => $credentials->username,
			),
			__METHOD__
		);
	}

	/**
	 * Returns a URL of a wiki page which does not have the 444
	 * port.
	 */
	public static function getNormalURL( $title, $query = '' ) {
		global $wgMITCertificateServer;

		$base = $title->getLocalURL( $query );
		if( $wgMITNormalServer ) {
			return "https://{$wgMITNormalServer}{$base}";
		} else {
			return "https://{$_SERVER['SERVER_NAME']}{$base}";
		}
	}

	/**
	 * Generates a temporary authentication mark which may be used as a substitute
	 * of session data, in case when the cookies are undesirable or unusable.
	 * It is stored in the object cache, that is, memcached or, in worst case, database.
	 */
	public static function generateAuthenticationMark( $id, $longTerm = false ) {
		$memc = self::getRealCache();

		$mark = base_convert( MWCryptRand::generateHex( self::MARK_LENGTH ), 16, 32 );
		$expiry = wfTimestamp() + $longTerm ? self::MARK_EXPIRY_LONG : self::MARK_EXPIRY;
		$memc->set( wfMemcKey( 'mitauth', 'mark', $mark ), $id, $expiry  );
		return $mark;
	}

	/**
	 * Reclaim the mark generated by generateAuthenticationMark(). Note that
	 * this makes the mark invalid (i.e. it is deleted).
	 */
	public static function reclaimAuthenticationMark( $mark ) {
		$memc = self::getRealCache();

		$key = wfMemcKey( 'mitauth', 'mark', $mark );
		$id = $memc->get( $key );
		$memc->delete( $key );
		return $id;
	}

	public static function getMoiraGroupMembers( $groupname ) {
		$memc = self::getRealCache();

		$key = wfMemcKey( 'mitauth', 'moiragroup', $groupname );
		$value = $memc->get( $key );
		if( $value )
			return $value;

		$grouparg = wfEscapeShellArg( "system:{$groupname}" );
		$output = wfShellExec( "pts membership -noauth $grouparg" );
		$list = explode( "\n", trim($output) );
		$list = array_map( 'trim', $list );
		array_shift( $list );	// Remove the "Members of" line from pts output

		$memc->set( $key, $list, self::GROUP_EXPIRY );
		return $list;
	}
}

/**
 * A common interface for different authentication backends.
 */
interface MITAuthBackend {
	/**
	 * Redirect user to the URL where his credentials is read (444 port, Shibboleth,
	 * whatever). That URL should redirect him back to Special:MITLogin/auth and it
	 * should pass the $type parameter via the query as type=$type.
	 */
	function redirectToAuthenticator( $type, $query );

	/**
	 * After the user is redirected back to Special:MITLogin/auth, this method
	 * should return either null (if no data supplied), or an object with following
	 * fields:
	 * - username
	 * - realname
	 * - email
	 * - credentials (must be MITAuthCredentials object)
	 */
	function getAuthenticationData();
}
